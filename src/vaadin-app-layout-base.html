<!--
@license
Vaadin App Layout Base
Copyright (C) 2019 Vaadin Ltd
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../polymer/lib/utils/render-status.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../../vaadin-element-mixin/vaadin-element-mixin.html">
<link rel="import" href="safe-area-inset.html">
<link rel="import" href="detect-ios-navbar.html">

<dom-module id="vaadin-app-layout-base">
  <template>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
        --vaadin-app-layout-transition: 200ms;
        transition: padding var(--vaadin-app-layout-transition);
        /* TODO(jouni): only supports px values at the moment */
        --vaadin-app-layout-threshold: 800px;
      }

      :host([hidden]) {
        display: none !important;
      }

      [offset-element] {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        transition: all var(--vaadin-app-layout-transition);
      }

      :host([orientation="vertical"]) [offset-element] {
        bottom: auto;
      }

      :host([orientation="vertical-reverse"]) [offset-element] {
        top: auto;
      }

      :host([orientation="horizontal"]) [offset-element] {
        right: auto;
      }

      :host([orientation="horizontal-reverse"]) [offset-element] {
        left: auto;
      }

      [content-element] {
        height: 100%;
        overflow: auto;
      }

      :host(:not([ios-fix])) [content-element] {
        -webkit-overflow-scrolling: touch;
      }

      :host(.no-anim),
      :host(.no-anim) [offset-element] {
        transition: none !important;
      }
    </style>
    <div content-element>
      <slot></slot>
    </div>
    <div offset-element>
      <slot name="offset"></slot>
    </div>
  </template>

  <script>
    (function() {

      const templateCache = {};

      /**
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ThemableMixin
       * @private
       */
      class AppLayoutBaseElement extends Vaadin.ElementMixin(Vaadin.ThemableMixin(Polymer.Element)) {
        static get is() {
          return 'vaadin-app-layout-base';
        }

        static get properties() {
          return {
            /* vertical, vertical-reverse, horizontal, horizontal-reverse */
            orientation: {
              type: String,
              value: 'vertical',
              reflectToAttribute: true,
              observer: '_updateOffsetSize'
            },

            /* Is the [offset-element] using fixed positioning */
            fixed: {
              type: Boolean,
              value: false,
              reflectToAttribute: true
            }
          };
        }

        static _modifiedTemplate(layoutName) {
          if (!templateCache[layoutName]) {
            const template = super.template.cloneNode(true);
            template.content.querySelector('[offset-element]').setAttribute('part', layoutName);
            template.content.querySelector('[offset-element] slot').setAttribute('name', layoutName);
            const extraModule = Polymer.DomModule.prototype.modules[`vaadin-${layoutName}-layout-style`];
            const style = extraModule.querySelector('template').content.querySelector('style');
            template.content.insertBefore(style, template.content.querySelector('style').nextSibling);
            templateCache[layoutName] = template;
          }
          return templateCache[layoutName];
        }

        constructor() {
          super();
          // TODO(jouni): might want to debounce
          this.__boundResizeListener = this._resize.bind(this);
        }

        connectedCallback() {
          super.connectedCallback();
          window.addEventListener('resize', this.__boundResizeListener);

          Polymer.RenderStatus.afterNextRender(this, this._updateOffsetSize);

          if (window.HTMLImports && !window.HTMLImports.useNative) {
            // Wait for all children to upgrade before trying to measure sizes
            Array.from(this.querySelectorAll('*')).forEach(child => {
              if (child.localName.indexOf('-') > -1) {
                window.customElements.whenDefined(child.localName).then(() => {
                  // TODO(jouni): might want to debounce
                  this._updateOffsetSize();
                });
              }
            });
          }
        }

        disconnectedCallback() {
          window.removeEventListener('resize', this.__boundResizeListener);
          super.disconnectedCallback();
        }

        _resize() {
          this._blockAnimationUntilAfterNextRender();
        }

        _updateOffsetSize(animate) {
          // Ignore initial property observer callbacks
          if (arguments.length == 2 && arguments[1] === undefined) {
            return;
          }

          const offsetElement = this.shadowRoot.querySelector('[offset-element]');

          const rect = offsetElement.getBoundingClientRect();
          let size = rect.width + 'px';
          if (this.orientation.indexOf('horizontal') == -1) {
            size = rect.height + 'px';
          }

          this.style.setProperty(`--${this.localName}-offset`, size);

          if (!animate) {
            this._blockAnimationUntilAfterNextRender();
          }
        }

        _blockAnimationUntilAfterNextRender() {
          this.classList.add('no-anim');
          Polymer.RenderStatus.afterNextRender(this, () => this.classList.remove('no-anim'));
        }
      }

      /**
       * @namespace Vaadin
       */
      window.Vaadin.AppLayoutBaseElement = AppLayoutBaseElement;
    })();
  </script>
</dom-module>
